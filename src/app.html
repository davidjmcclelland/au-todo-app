<!--In order to render, we need to create a view for the app component. This introduces the next convention of Aurelia. To create a view for any class, simply create an HTML file with the same name as the ES Next module but change the file extension to .html. Inside that view, you can place an HTML 5 template with data binding expressions declaring how the view should render an instance of the class. Let's start with a very basic view of our app.-->

<template>
    <h1>${heading}</h1>


    <!--
    There are a couple of things to notice here. First, all views are wrapped in a Web Components template element.

    Second, did you notice the ${heading} syntax? Well, inside of a view, you have access to all the properties and methods of the class instance associated with that View and you can access them inside the content of any element or attribute by using the ES Next template string syntax as shown above.

       The above syntax creates a one-way data-binding to the heading property. By "one-way" we mean that the dataflow is unidirectional and only changes to the heading property will affect the view. There is no "reverse" flow from the view back to the view-model.

       We call a View's associated class its View-Model because it's a model for, or a model of the View. Most Aurelia development leverages the Model - View - View-Model pattern. However, Aurelia is flexible enough to enable also using patterns like Supervising Controller, Passive View and Model - View - Controller if desired.    -->

    <form submit.trigger="addTodo()">
        <input type="text" value.bind="todoDescription"/>
        <button type="submit">Add Todo</button>
    </form>

    <!-- value.bind is aurelia putting a Javascript string into a binding with a text value
    in an html element.
    The javascript must be a property of the corresponding class for this page (aka the view)
    which places it in app.js aka the view-model.
    When you look in app.js you will find this.todoDescription in the class constructor -->

    <!-- important note about binding choices: Aurelia works on your behalf to pick the most sensible "binding mode" based on the element and attribute you are binding. For example, since this is an input and you are binding its value then .bind will cause Aurelia to set up a two-way binding. This means that any time the view-model's todoDescription changes, it will be updated in the input's value property but also any time the input's value property changes, the view-model will have its todoDescription updated as well.

    Aurelia will use two-way binding for all form control value bindings and one-way binding for everything else. However, you can always override this by using an explicit binding command. For example, instead of using .bind you can use .one-way, .two-way or .one-time. Similarly, you can use .delegate for event delegation in place of .trigger. -->

    <!-- There's something else of note in this markup though. We can not only bind properties, but you can attach to events. Take a look at the form element itself. In Aurelia, you can take any DOM event and append .trigger to it. This means that when that event fires, it will trigger the associated expression to be evaluated. In this case, the submit event causes the addTodo() method to be invoked. Because we've used the submit event, it means that the to-do will be added either by pressing the submit button or by pressing enter while inside the input. -->


    <!-- adding elements to the DOM from the view-model -->
    <ul>
        <li repeat.for="toDont of todos">
            <!-- to-do of todos is aurelia reference to todos array of app.js
            the to-do part could be called anything, iots a local reference
            in fact I renamed it toDont for laughs here. -->
            <input type="checkbox" checked.bind="toDont.done">
            <span>${toDont.description}</span>
            <!-- note description is a property of the to-do class not todoDescrition
            of the app class. -->
            <button click.trigger="removeTodo(toDont)">Remove</button>
        </li>
    </ul>

    <!-- to summarize: To generate HTML based on an Array, Map or Set, we use the repeat.for="local of collection" syntax. This syntax is derived from the for...of loop of ES Next itself. As you can see above, we want to generate one li for each item in our todos array. So, we place a repeat.for attribute on the li we want to be generated and we specify the todos collection and that we want the local loop variable to be named to-do. With this we can bind to any property of the to-do instance. So, you can see how we're just re-applying all the same techniques from above now. We're binding the checked attribute to the to-do's done property and its description property is being injected into the content of the span. Finally, we're adding a trigger on the button's click event so that we can remove the to-do. Notice that the removeTodo is still in scope. Just like in ES Next, inside a loop, you still have access to the variable in the outer block. This allows us to call the removeTodo method on the App class, passing in the particular To-do instance that we want to remove. -->
</template>